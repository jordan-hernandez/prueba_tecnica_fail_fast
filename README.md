# Sistema de Inventario Multi-Bodega

**Prueba T√©cnica Backend - Django REST Framework + PostgreSQL**

Sistema completo de gesti√≥n de inventario multi-bodega con funcionalidades avanzadas de consultas, JOINs parametrizables y comparaci√≥n de rendimiento entre Django ORM y funciones SQL nativas de PostgreSQL.

## üéØ Caracter√≠sticas Principales

- **Inventario Multi-Bodega**: Gesti√≥n de stock en m√∫ltiples ubicaciones
- **Sistema de √ìrdenes**: Creaci√≥n y gesti√≥n de √≥rdenes con items m√∫ltiples
- **Gesti√≥n de Pagos**: Sistema completo de pagos con diferentes m√©todos
- **API REST Completa**: CRUD para todos los modelos
- **M√©todo get_related Gen√©rico**: JOINs parametrizables y filtros avanzados
- **Funciones SQL PostgreSQL**: Implementaci√≥n nativa para comparaci√≥n de rendimiento
- **Datos de Prueba**: Sistema autom√°tico de carga de fixtures

## üß∞ Tecnolog√≠as

- **Backend**: Django 4.2.7, Django REST Framework 3.14.0
- **Base de Datos**: PostgreSQL
- **Lenguaje**: Python 3.8+
- **Arquitectura**: API REST con ViewSets personalizados

## üì¶ Estructura del Proyecto

```
prueba_tecnica_backend/
‚îú‚îÄ‚îÄ inventory_system/           # Configuraci√≥n principal Django
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îú‚îÄ‚îÄ settings.py            # Configuraci√≥n del proyecto
‚îÇ   ‚îú‚îÄ‚îÄ urls.py               # URLs principales
‚îÇ   ‚îú‚îÄ‚îÄ wsgi.py
‚îÇ   ‚îî‚îÄ‚îÄ asgi.py
‚îú‚îÄ‚îÄ inventory/                 # Aplicaci√≥n principal
‚îÇ   ‚îú‚îÄ‚îÄ models.py             # Modelos de datos (UML implementado)
‚îÇ   ‚îú‚îÄ‚îÄ serializers.py        # Serializers DRF
‚îÇ   ‚îú‚îÄ‚îÄ views.py              # ViewSets con m√©todo get_related
‚îÇ   ‚îú‚îÄ‚îÄ admin.py              # Configuraci√≥n admin Django
‚îÇ   ‚îú‚îÄ‚îÄ urls.py               # URLs de la aplicaci√≥n
‚îÇ   ‚îú‚îÄ‚îÄ sql_functions.py      # Funciones SQL PostgreSQL
‚îÇ   ‚îú‚îÄ‚îÄ management/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ commands/
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ load_sample_data.py    # Cargar datos de prueba
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ compare_sql.py         # Comparar ORM vs SQL
‚îÇ   ‚îî‚îÄ‚îÄ migrations/
‚îú‚îÄ‚îÄ manage.py
‚îú‚îÄ‚îÄ requirements.txt
‚îî‚îÄ‚îÄ README.md
```

## üèóÔ∏è Modelos Implementados

### Diagrama de Relaciones

El sistema implementa los siguientes modelos seg√∫n el diagrama UML:

- **Brand**: Marcas de productos
- **Category**: Categor√≠as de productos  
- **Product**: Productos con SKU, precio y relaciones
- **Warehouse**: Bodegas/almacenes
- **Stock**: Stock por producto y bodega (constraint √∫nico)
- **Customer**: Clientes del sistema
- **Order**: √ìrdenes de compra
- **OrderItem**: Items de las √≥rdenes
- **Payment**: Pagos de las √≥rdenes

### Constraints Implementados

```sql
-- Stock √∫nico por producto y bodega
CONSTRAINT unique_product_warehouse_stock

-- Stock reservado no puede superar cantidad total
CONSTRAINT reserved_lte_qty

-- Producto √∫nico por orden (no duplicados)
CONSTRAINT unique_order_product
```

## üöÄ Instalaci√≥n y Configuraci√≥n

### 1. Requisitos Previos

- Python 3.8+
- PostgreSQL 12+
- pip (gestor de paquetes Python)

### 2. Configuraci√≥n del Entorno

```bash
# Clonar el repositorio
git clone <repository-url>
cd prueba_tecnica_backend

# Crear y activar entorno virtual
python -m venv venv

# Windows
venv\Scripts\activate

# Linux/Mac
source venv/bin/activate

# Instalar dependencias
pip install -r requirements.txt
```

### 3. Configuraci√≥n de Base de Datos

```sql
-- Crear base de datos PostgreSQL
CREATE DATABASE inventory_db;
CREATE USER postgres WITH PASSWORD 'postgres';
GRANT ALL PRIVILEGES ON DATABASE inventory_db TO postgres;
```

**Configuraci√≥n en `settings.py`:**
```python
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.postgresql',
        'NAME': 'inventory_db',
        'USER': 'postgres',
        'PASSWORD': 'postgres',
        'HOST': 'localhost',
        'PORT': '5432',
    }
}
```

### 4. Ejecutar Migraciones

```bash
# Crear migraciones
python manage.py makemigrations

# Aplicar migraciones
python manage.py migrate

# Crear superusuario (opcional)
python manage.py createsuperuser
```

### 5. Cargar Datos de Prueba

```bash
# Cargar datos de ejemplo
python manage.py load_sample_data

# O limpiar y cargar datos nuevos
python manage.py load_sample_data --clear
```

### 6. Crear Funciones SQL

```bash
# Ejecutar en PostgreSQL las funciones del archivo sql_functions.py
python manage.py dbshell

# Luego copiar y ejecutar las funciones de inventory/sql_functions.py
```

### 7. Ejecutar Servidor

```bash
python manage.py runserver
```

La API estar√° disponible en: `http://localhost:8000/api/v1/`

## üì° Endpoints de la API

### Endpoints Base (CRUD)

| Endpoint | M√©todos | Descripci√≥n |
|----------|---------|-------------|
| `/api/v1/brands/` | GET, POST, PUT, PATCH, DELETE | Gesti√≥n de marcas |
| `/api/v1/categories/` | GET, POST, PUT, PATCH, DELETE | Gesti√≥n de categor√≠as |
| `/api/v1/products/` | GET, POST, PUT, PATCH, DELETE | Gesti√≥n de productos |
| `/api/v1/warehouses/` | GET, POST, PUT, PATCH, DELETE | Gesti√≥n de bodegas |
| `/api/v1/stocks/` | GET, POST, PUT, PATCH, DELETE | Gesti√≥n de stock |
| `/api/v1/customers/` | GET, POST, PUT, PATCH, DELETE | Gesti√≥n de clientes |
| `/api/v1/orders/` | GET, POST, PUT, PATCH, DELETE | Gesti√≥n de √≥rdenes |
| `/api/v1/order-items/` | GET, POST, PUT, PATCH, DELETE | Items de √≥rdenes |
| `/api/v1/payments/` | GET, POST, PUT, PATCH, DELETE | Gesti√≥n de pagos |

### Endpoints Especiales

| Endpoint | M√©todo | Descripci√≥n |
|----------|--------|-------------|
| `/api/v1/products/get_related/` | GET | M√©todo gen√©rico con JOINs |
| `/api/v1/products/low_stock/` | GET | Productos con stock bajo |
| `/api/v1/orders/{id}/confirm/` | POST | Confirmar orden y reservar stock |
| `/api/v1/payments/{id}/confirm/` | POST | Confirmar pago |

## üîó M√©todo get_related - JOINs Parametrizables

### Funcionalidad Principal

El m√©todo `get_related` permite realizar consultas complejas con JOINs parametrizables, filtros anidados y selecci√≥n de campos espec√≠ficos.

### Par√°metros de Query

| Par√°metro | Descripci√≥n | Ejemplo |
|-----------|-------------|---------|
| `join` | Relaciones a incluir | `join=brand,category,stocks__warehouse` |
| `fields[modelo]` | Campos espec√≠ficos por modelo | `fields[product]=name,sku&fields[brand]=name` |
| `filter[modelo]` | Filtros por modelo | `filter[brand]=name__icontains=Samsung` |
| `ordering` | Ordenamiento | `ordering=name,-created_at` |
| `distinct` | Eliminar duplicados | `distinct=true` |
| `limit` | Limitar resultados | `limit=10` |

### Ejemplos de Uso

#### 1. Productos de Samsung ordenados por nombre
```
GET /api/v1/products/get_related/?join=brand,category&filter[brand]=name__icontains=Samsung&ordering=name
```

#### 2. Productos con campos espec√≠ficos y filtros
```
GET /api/v1/products/get_related/?join=brand,category&fields[product]=name,sku,price&fields[brand]=name&filter[product]=is_active=true
```

#### 3. Productos de una marca en √≥rdenes de un cliente espec√≠fico
```
GET /api/v1/products/get_related/?join=brand,order_items__order__customer&filter[brand]=name__icontains=Samsung&filter[customer]=email=john@example.com&distinct=true
```

#### 4. Stock por bodega con informaci√≥n completa
```
GET /api/v1/stocks/get_related/?join=product__brand,product__category,warehouse&fields[stock]=qty,reserved&fields[product]=name,sku&fields[warehouse]=name,city
```

### Respuesta del M√©todo get_related

```json
{
  "count": 2,
  "results": [
    {
      "id": "uuid-here",
      "name": "Samsung QLED 55\" 4K Smart TV",
      "sku": "TV-SAMSUNG-001",
      "price": "1299.99",
      "brand": {
        "name": "Samsung"
      },
      "category": {
        "name": "Televisores"
      }
    }
  ],
  "sql_query": "SELECT ... FROM inventory_product ..."
}
```

## üóÑÔ∏è Funciones SQL PostgreSQL

### Funciones Implementadas

#### 1. get_products_by_brand_and_customer
Obtiene productos de una marca espec√≠fica que aparecen en √≥rdenes de un cliente.

```sql
SELECT * FROM get_products_by_brand_and_customer('Samsung', 'john@example.com');
```

#### 2. get_payments_by_product_quantity
Obtiene pagos donde se factur√≥ un producto por m√°s de X unidades.

```sql
SELECT * FROM get_payments_by_product_quantity('TV-SAMSUNG-001', 5);
```

#### 3. get_stock_analysis
An√°lisis completo de stock por bodega.

```sql
SELECT * FROM get_stock_analysis('Bodega Central', 10);
```

#### 4. get_top_selling_products
Top de productos m√°s vendidos.

```sql
SELECT * FROM get_top_selling_products(10, '2024-01-01', '2024-12-31');
```

## üî¨ Comparaci√≥n ORM vs SQL

### Ejecutar Comparaci√≥n

```bash
# Comparar todos los casos
python manage.py compare_sql

# Comparar caso espec√≠fico
python manage.py compare_sql --case products_by_brand_customer --brand-name Samsung --customer-email john@example.com

# Comparar pagos por cantidad
python manage.py compare_sql --case payments_by_quantity --product-sku TV-SAMSUNG-001 --min-quantity 1
```

### An√°lisis de Resultados

**Django ORM:**
- ‚úÖ **Ventajas**: Abstracci√≥n, seguridad, portabilidad, mantenimiento
- ‚ùå **Desventajas**: Overhead de conversi√≥n, posible problema N+1, mayor uso de memoria

**Funciones PostgreSQL:**
- ‚úÖ **Ventajas**: Velocidad superior, optimizaci√≥n del motor DB, menor uso de memoria
- ‚ùå **Desventajas**: Acoplamiento a PostgreSQL, mantenimiento manual, menos seguridad

**Complejidad Temporal:**
- **ORM**: O(n) + overhead de Python + m√∫ltiples consultas
- **SQL**: O(n) optimizado por motor de base de datos

**Complejidad Espacial:**
- **ORM**: O(n) + objetos Python + cache del ORM
- **SQL**: O(n) solo resultados finales

## üß™ Casos de Uso de Testing

### Datos Pre-cargados

El comando `load_sample_data` crea:

- **5 Marcas**: Samsung, LG, Sony, Apple, Xiaomi
- **5 Categor√≠as**: Televisores, Smartphones, Laptops, Tablets, Electrodom√©sticos
- **10 Productos**: Diversos productos de diferentes marcas
- **4 Bodegas**: En Bogot√°, Medell√≠n, Cartagena, Cali
- **40 Registros de Stock**: 10 productos √ó 4 bodegas
- **5 Clientes**: Con emails espec√≠ficos para testing
- **6 √ìrdenes**: Con diferentes estados y productos
- **Pagos**: Para √≥rdenes confirmadas

### Casos de Prueba Espec√≠ficos

1. **Brand + Customer**: Samsung products para john@example.com
2. **Product Quantity**: TV-SAMSUNG-001 con cantidad >= 1
3. **Stock Analysis**: An√°lisis por bodega "Bodega Central"
4. **Low Stock**: Productos con stock menor a 10 unidades

## üéÆ Ejemplos con cURL

### Crear Producto
```bash
curl -X POST http://localhost:8000/api/v1/products/ \
  -H "Content-Type: application/json" \
  -d '{
    "name": "Test Product",
    "sku": "TEST-001",
    "price": "99.99",
    "brand": "brand-uuid",
    "category": "category-uuid",
    "is_active": true
  }'
```

### Consulta get_related
```bash
curl "http://localhost:8000/api/v1/products/get_related/?join=brand,category&filter[brand]=name__icontains=Samsung&ordering=name"
```

### Confirmar Orden
```bash
curl -X POST http://localhost:8000/api/v1/orders/order-uuid/confirm/
```

## üìä Colecci√≥n Postman

### Requests Incluidos

1. **CRUD Completo de Products**
   - GET /products/ (List)
   - POST /products/ (Create) 
   - GET /products/{id}/ (Detail)
   - PUT /products/{id}/ (Update)
   - DELETE /products/{id}/ (Delete)

2. **M√©todo get_related Examples**
   - Products with Brand and Category
   - Products by Brand Samsung
   - Products in Customer Orders
   - Stock Analysis with Joins
   - Custom Fields Selection

3. **Business Logic**
   - Low Stock Products
   - Confirm Order
   - Confirm Payment
   - Customer Orders

4. **SQL Functions Testing**
   - Test equivalent queries

### Variables de Entorno Postman

```json
{
  "base_url": "http://localhost:8000/api/v1",
  "samsung_brand_id": "{{brand_id}}",
  "test_customer_email": "john@example.com",
  "test_product_sku": "TV-SAMSUNG-001"
}
```

## üêõ Debugging y Desarrollo

### Ver SQL Generado

```python
# En Django shell
from inventory.models import Product
qs = Product.objects.select_related('brand').filter(brand__name='Samsung')
print(str(qs.query))
```

### Logs de SQL

El proyecto est√° configurado para mostrar todas las consultas SQL en modo DEBUG:

```python
LOGGING = {
    'loggers': {
        'django.db.backends': {
            'level': 'DEBUG',
            'handlers': ['console'],
        }
    }
}
```

### Testing

```bash
# Ejecutar tests
python manage.py test

# Test espec√≠fico
python manage.py test inventory.tests.test_models

# Con coverage
coverage run manage.py test
coverage html
```

## üîß Configuraci√≥n Adicional

### Variables de Entorno (.env)

```bash
DEBUG=True
SECRET_KEY=your-secret-key
DB_NAME=inventory_db
DB_USER=postgres
DB_PASSWORD=postgres
DB_HOST=localhost
DB_PORT=5432
```

### Configuraci√≥n para Producci√≥n

```python
# settings.py para producci√≥n
DEBUG = False
ALLOWED_HOSTS = ['your-domain.com']

# Base de datos con connection pooling
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.postgresql',
        'OPTIONS': {
            'MAX_CONNS': 20,
            'OPTIONS': {
                'MAX_CONNS': 20,
            }
        }
    }
}
```

## üìà M√©tricas de Rendimiento

### Benchmarks Esperados

- **ORM Queries**: ~50-100ms para consultas complejas
- **SQL Functions**: ~10-30ms para las mismas consultas
- **Memory Usage**: SQL functions usan ~60% menos memoria
- **Scalability**: SQL functions escalan mejor con grandes datasets

### Optimizaciones Implementadas

1. **√çndices de Base de Datos**: En campos frecuentemente consultados
2. **select_related / prefetch_related**: Para evitar N+1 queries
3. **Constraints a Nivel DB**: Para integridad de datos
4. **Conexi√≥n Pooling**: Para mejor rendimiento
5. **Query Optimization**: An√°lisis de planes de ejecuci√≥n

## ü§ù Contribuci√≥n

### Extensiones Posibles

1. **Cache**: Implementar Redis para cacheo de consultas frecuentes
2. **Elasticsearch**: Para b√∫squedas de texto completo
3. **GraphQL**: API alternativa con Apollo Server
4. **Docker**: Containerizaci√≥n completa
5. **CI/CD**: Pipeline de integraci√≥n continua
6. **Monitoring**: APM con New Relic o DataDog

### Estructura de Contribuci√≥n

```bash
# Fork del repositorio
git clone your-fork-url
cd prueba_tecnica_backend

# Crear rama feature
git checkout -b feature/nueva-funcionalidad

# Hacer cambios y commit
git commit -m "Add: nueva funcionalidad"

# Push y crear PR
git push origin feature/nueva-funcionalidad
```

## üìù Licencia

Este proyecto es parte de una prueba t√©cnica y est√° disponible bajo licencia MIT.

---

**Desarrollado como parte de la prueba t√©cnica Backend - Django REST Framework + PostgreSQL**

Para dudas o consultas sobre la implementaci√≥n, revisar la documentaci√≥n de c√≥digo o contactar al desarrollador. 